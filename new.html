<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no"/>
    <script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=true"></script>
    <script type="text/javascript" src="http://mbostock.github.com/d3/d3.js?1.29.1"></script>
    <style type="text/css">

      html, body, #map {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #main, #main svg {
        position: absolute;
      }

      #main svg {
        width: 60px;
        height: 20px;
        padding-right: 100px;
        font: 10px sans-serif;
      }

      #main circle {
        fill: brown;
        stroke: black;
        stroke-width: 1.5px;
      }

      .links {
        position:absolute;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <script src="./Path demonstration_files/pathlayout.js"></script>
    <script type="text/javascript">

      var width  = 500;
      var height = 500;

      var map = new google.maps.Map(d3.select("#map").node(), {
        zoom:10,
        center: new google.maps.LatLng(21.386473, 39.438679),
        mapTypeId: google.maps.MapTypeId.TERRAIN
      });

      var overlay = new google.maps.OverlayView();

      overlay.onAdd = function() {
          var layer = d3.select(this.getPanes().overlayLayer).append("div")
              .attr("id", "main")
              .attr("width","100%")
              .attr("height","100%");

          overlay.draw = function() {

            var projection = this.getProjection();
            var padding = 10;

            var route = []

            d3.json("google_directions_api_response.json", function(data, error) {
                console.log(data);
                
                legs = data['routes'][0]['legs'];
                legs.forEach(function(leg){
                    steps = leg['steps'];
                    number_steps = d3.range(steps.length);
                    number_steps.forEach(function(i){

                        sl = steps[i]['start_location'];
                        sl = new google.maps.LatLng(sl["lat"], sl["lng"]);
                        sl = projection.fromLatLngToDivPixel(sl);

                        el = steps[i]['end_location'];
                        el = new google.maps.LatLng(el["lat"], el["lng"]);
                        el = projection.fromLatLngToDivPixel(el);
                        route.push({"x1": sl.x, "y1": sl.y, "x2":el.x, "y2":el.y});
                      
                    });
                });


                console.log(route);
                
                var links = layer.selectAll(".links")
                  .data(route)
                  .each(pathTransform) // update existing markers       
                .enter().append("svg:svg")
                 .attr("class", "links")
                  .each(pathTransform);

      function pathTransform(d) {
        var radius = 5;
        var t, b, l, r, w, h, currentSvg;

        if ( d['y1'] < d['y2'] ) { t = d['y1']; b = d['y2']; }
        else                     { t = d['y2']; b = d['y1']; }
        
        if ( d['x1'] < d['x2'] ) { l = d['x1']; r = d['x2']; }
        else                     { l = d['x2']; r = d['x1']; }

        currentSvg = d3.select(this)
          .style("left", (l + radius) + "px")
          .style("top", (t + radius) + "px")
          .style("width", (r - l - radius) + "px")
          .style("height", (b - t - radius) + "px");

        if (( d['y1'] < d['y2']) && ( d['x1'] < d['x2'])) {
        currentSvg.append("svg:line")
            .style("stroke-width", 3)
            .style("stroke", "orange")
            .attr("y1", 0)
            .attr("x1", 0)
            .attr("x2", r-l)
            .attr("y2", b-t)
                .transition()
                  .duration(5000)
                  .style("opacity",0)
                .remove();

        } else if ((d['x1'] > d['x2']) && (d['y1'] > d['y2'])){
        currentSvg.append("svg:line")
            .style("stroke-width", 3)
            .style("stroke", "orange")
            .attr("y1", 0)
            .attr("x1", 0)
            .attr("x2", r-l)
            .attr("y2", b-t)
                .transition()
                  .duration(5000)
                  .style("opacity",0)
                .remove();

        } else if (( d['y1'] < d['y2']) && ( d['x1'] > d['x2'])){
            currentSvg.append("svg:line")
                .style("stroke-width", 3)
                .style("stroke", "orange")
                .attr("y1", 0)
                .attr("x2", 0)
                .attr("x1", r-l)
                .attr("y2", b-t)
                .transition()
                  .duration(5000)
                  .style("opacity",0)
                .remove();

            } else if ((d['x1'] < d['x2']) && (d['y1'] > d['y2'])){
            currentSvg.append("svg:line")
                .style("stroke-width", 3)
                .style("stroke", "orange")
                .attr("y1", 0)
                .attr("x2", 0)
                .attr("x1", r-l)
                .attr("y2", b-t)
                .transition()
                  .duration(5000)
                  .style("opacity",0)
                .remove();
            } else {
              console.log("something is wrong!!!");
            }


            return currentSvg;
          } 

                
        });
      };
    };

        

        // Bind our overlay to the mapâ€¦
        overlay.setMap(map);
      // });

    </script>
  </body>
</html>